---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# RBCFTools

<!-- badges: start -->
[![R-CMD-check](https://github.com/RGenomicsETL/RBCFTools/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/RGenomicsETL/RBCFTools/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

RBCFTools provides R bindings to [bcftools](https://github.com/samtools/bcftools) and [htslib](https://github.com/samtools/htslib), the standard tools for reading and manipulating VCF/BCF files. The package bundles these libraries, so no external installation is required.

## Installation

You can install the development version of RBCFTools from [GitHub](https://github.com/RGenomicsETL/RBCFTools) with:
 
```r
# install.packages("pak")
pak::pak("RGenomicsETL/RBCFTools")
```

## Version Information

```{r versions}
library(RBCFTools)

# Get library versions
bcftools_version()
htslib_version()
```

## Tool Paths

RBCFTools bundles bcftools and htslib command-line tools. Use the path functions to locate the executables

```{r paths}
# Main executables
bcftools_path()
bgzip_path()
tabix_path()

# List all available tools
bcftools_tools()
htslib_tools()
```

## Capabilities

Check which features were compiled into htslib

```{r capabilities}
# Get all capabilities as a named list
htslib_capabilities()

# Human-readable feature string
htslib_feature_string()
```

### Feature Constants

Use `HTS_FEATURE_*` constants to check for specific features
 
```{r features}
# Check individual features
htslib_has_feature(HTS_FEATURE_LIBCURL)  # Remote file access via libcurl
htslib_has_feature(HTS_FEATURE_S3)       
htslib_has_feature(HTS_FEATURE_GCS)      # Google Cloud Storage
htslib_has_feature(HTS_FEATURE_LIBDEFLATE)
htslib_has_feature(HTS_FEATURE_LZMA)
htslib_has_feature(HTS_FEATURE_BZIP2)
```

These are useful for conditionally enabling features in your code.

## Example: Query Remote VCF from S3

With libcurl support, bcftools can directly query remote files. Here we count variants in a small region from the 1000 Genomes cohort VCF on S3:

```{r s3-example, eval=TRUE}
# Setup environment for remote file access (S3/GCS)
setup_hts_env()

# Build S3 URL for 1000 Genomes cohort VCF
s3_base <- "s3://1000genomes-dragen-v3.7.6/data/cohorts/"
s3_path <- "gvcf-genotyper-dragen-3.7.6/hg19/3202-samples-cohort/"
vcf_file <- "3202_samples_cohort_gg_chr22.vcf.gz"
vcf_url <- paste0(s3_base, s3_path, vcf_file)

# Query a small region (chr22:20000000-20100000) and count variants
result <- system2(
  bcftools_path(),
  args = c("view", "-H", "-r", "chr22:20000000-20100000", vcf_url),
  stdout = TRUE,
  stderr = FALSE
)
length(result)
```

## (Experimental) VCF to Arrow

RBCFTools provides streaming VCF/BCF to Apache Arrow conversion via [nanoarrow](https://arrow.apache.org/nanoarrow/). This enables integration with tools like [duckdb](https://github.com/duckdb/duckdb-r), and parquet format.

The Arrow conversion performs VCF spec conformance checks on headers (similar to htslib's `bcf_hdr_check_sanity()`) and emits R warnings when correcting non-conformant fields. In the examples below, we suppress these warnings for cleaner output.

```{r arrow-setup, include=FALSE}
bcf_file <- system.file("extdata", "1000G_3samples.bcf", package = "RBCFTools")
parquet_file <- tempfile(fileext = ".parquet")
```

### Read VCF as Arrow Stream

```{r arrow-stream, eval=TRUE}
# Open BCF as Arrow array stream
stream <- vcf_open_arrow(bcf_file, batch_size = 100L)

# Read first batch
batch <- stream$get_next()
b <- nanoarrow::convert_array(batch)
b
```

### Convert to Data Frame

```{r arrow-df, eval=TRUE}
# Convert entire BCF to data.frame
df <- vcf_to_arrow(bcf_file, as = "data.frame")
head(df[, c("CHROM", "POS", "REF", "ALT", "QUAL")])
```

### Write to Parquet

If you have the arrow package installed

```{r parquet, eval=TRUE}
# Convert BCF to Parquet
options(warn = -1)  # Suppress warnings for cleaner README output
vcf_to_parquet(bcf_file, parquet_file, compression = "gzip")

# Read back with arrow
pq_bcf <- arrow::read_parquet(parquet_file)
pq_bcf
```

### Query with DuckDB

using [{duckdb}](https://github.com/duckdb/duckdb-r) 

```{r duckdb, eval=TRUE}
# SQL queries on BCF (requires arrow and duckdb packages)
vcf_query(bcf_file, "SELECT CHROM, COUNT(*) as n FROM vcf GROUP BY CHROM")

# Filter variants by position
vcf_query(bcf_file, "SELECT CHROM, POS, REF, ALT FROM vcf  LIMIT 5")
```

## References

- [bcftools documentation](https://samtools.github.io/bcftools/)
- [bcftools GitHub](https://github.com/samtools/bcftools)
- [htslib GitHub](https://github.com/samtools/htslib)
- [arrow-nanoarrow](https://arrow.apache.org/nanoarrow/)
